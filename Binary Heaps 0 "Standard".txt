Heap is a tree that satisfies the heazp property 
    - Max-Heap: Every parent node is greater than or equal to its children
    - Min-Heap: Every parent node is less than or equal to its children

Aspect              |Binary Tree                                  |Heap Tree           
-------------------------------------------------------------------------------------- 
Structure           |General Shape, can be unbalanced             |Complete Binary Tree(always balanced)
Node Ordering       |No specific order required                   |Must satisfy the heap proeprty (min/max)
Efficiency          |Dpends on type(e.g BST for fast, searching)  |Efficient for find max/min
Applications        |Searching, Parsing, decision-making          |Priority queues, heapsort, graph algorithms
    

Why Heap Tree? why use them? How they work? what problems they solve?

Problems that heaps can solve that other data/algorithm can solve as well however either time consuming or Time Complexity is long
say we have tasks to complete, and each task has a priority, a number represent task importance such as

task                | Importance or Priority
--------------------------------------------
Exercise            |   1
Cleaning            |   5
Wash Dishes         |   9
Email               |   4
Grocery Shopping    |   2
Reading             |   6

Say for example you want to organise tasks so can easily ass those task from importance
this way of structuring data is known as Priority Queue, Collection of value where we have access to the most importan item,
how you store this data? in a data structure such as 1.Array problem with array have fixed 
length, Static arrays have their size or length determined when the array is create and/or allocated.
 that can cause you to running into problems when want to add new element into the array. 

Other solution is linked list each node has pointer to the next data, however they is a problem when comes 
to time complexity, for example if you need to insert into linked list will need to traverse through the data 
structure time consuming. 

This where Binary heaps tree solves this problem of Linked-List, as Heaps use nodes same as Linked List difference
is instead of each single node pointing to another node only its structure, heaps have parent nodes pointing to 2 single children
nodes, those childs known as left child and right child. heaps can have 2 children or single child, left node only, right node only,
or both nodes. each node in a binary heap tree obyes Invariant otherwords propertiy that will always be true, in both binary heaps or 
different type of binary tree known as min-heap.

Invariant rule
The value of any node most be less than or more than its children nodes or atleast equal tool
           4 
        /     \
       6       7
      4<6      4<7
           or
      4=6      4=7

Operation for tasks
1. Insertion 
2. Deletion

Say we want to add a new value to tree, 3, they are 2 factors 
1. Shape: What the shape of Heaps Tree will be 
2. Invariant: Nodes are not greater then they children

Idealy will want the left:1 value side, and right:1 side to be balanced, if its unblanced the heaps will be unefficient
left side 2, right side 4 however depending on the nodes in the heaps can be difficulte to be balanced, to re-account for that
will have 1 extra node, on the unbalnced side, 

step 1. balanced but we want to add 1 more, to the tree 1 more node will make it unblance, thats why add one 
more on step 2.
           0 
        /     \
       0       0

step 2. add a extra node, 
Remeberer to always to add to the left node before the right node.
           0 
        /     \
       0       0
      /       
     0  <----- the node we wanted to adds

step 3. The extra node to balance the node, The fith node must be the child of the 3 node
           0 
        /     \
       0       0
      /       /
     0       0 <---5th node

step 4. Missing information solve later 
This is the shape to maintain
                 0
              /     \
             0       0
           /   \   /   \
          0    0  0     0









----------------Insertion
say you add a new node to this
                 4
              /     \
             6       7
           /   \   /   \
          8    11 9     10
        /
       5

The Invarient rule is broken as 8 > 5, so we need to make adjustment to the tree, 
if the invarient is greater then the parent swap the node

Step 1. one to fix "Invarient"
                 4
              /     \
             6       7
           /   \   /   \
          5    11 9     10
        /
       8

Step 2. one to fix "Invarient"
                 4
              /     \
             5       7
           /   \   /   \
          6    11 9     10
        /
       8
when we reach a node that the parent node is not greater than the child

-----------------Deletion







